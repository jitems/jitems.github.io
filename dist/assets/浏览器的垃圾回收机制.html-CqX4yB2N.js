import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,o as i,d as r}from"./app-Bi9sAhmd.js";const a={},n=r('<h1 id="浏览器的垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#浏览器的垃圾回收机制"><span>浏览器的垃圾回收机制</span></a></h1><p>**垃圾回收：**JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不再参与运行时，就需要系统收回被占用的内存空间。​如果不及时清理，会造成系统卡顿、内存溢出，这就是垃圾回收。</p><ul><li>JS 具有自动垃圾回收机制。垃圾收集器会按照固定的时间间隔周期性的执行。</li><li>JS 常见的垃圾回收方式：<strong>标记清除</strong>、<strong>引用计数方式</strong></li></ul><h2 id="哪些情况会导致内存泄漏" tabindex="-1"><a class="header-anchor" href="#哪些情况会导致内存泄漏"><span>哪些情况会导致内存泄漏</span></a></h2><ul><li>意外的全局变量：由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li><li>被遗忘的计时器或回调函数：设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li><li>脱离 DOM 的引用：获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</li><li>闭包：不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li></ul>',5),o=[n];function l(c,p){return i(),e("div",null,o)}const h=t(a,[["render",l],["__file","浏览器的垃圾回收机制.html.vue"]]),d=JSON.parse('{"path":"/%E7%9F%A5%E8%AF%86%E5%BA%93/JS/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html","title":"浏览器的垃圾回收机制","lang":"zh-CN","frontmatter":{"description":"浏览器的垃圾回收机制 **垃圾回收：**JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不再参与运行时，就需要系统收回被占用的内存空间。​如果不及时清理，会造成系统卡顿、内存溢出，这就是垃圾回收。 JS 具有自动垃圾回收机制。垃圾收集器会按照固定的时间间隔周期性的执行。 JS 常见的垃圾回收方式：标记清除、引用计数方式 哪些情况会...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/%E7%9F%A5%E8%AF%86%E5%BA%93/JS/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html"}],["meta",{"property":"og:site_name","content":"遐想的猫"}],["meta",{"property":"og:title","content":"浏览器的垃圾回收机制"}],["meta",{"property":"og:description","content":"浏览器的垃圾回收机制 **垃圾回收：**JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不再参与运行时，就需要系统收回被占用的内存空间。​如果不及时清理，会造成系统卡顿、内存溢出，这就是垃圾回收。 JS 具有自动垃圾回收机制。垃圾收集器会按照固定的时间间隔周期性的执行。 JS 常见的垃圾回收方式：标记清除、引用计数方式 哪些情况会..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-10T06:09:47.000Z"}],["meta",{"property":"article:author","content":"Mr.Liu"}],["meta",{"property":"article:modified_time","content":"2024-07-10T06:09:47.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"浏览器的垃圾回收机制\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-07-10T06:09:47.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Liu\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"哪些情况会导致内存泄漏","slug":"哪些情况会导致内存泄漏","link":"#哪些情况会导致内存泄漏","children":[]}],"git":{"createdTime":1720591787000,"updatedTime":1720591787000,"contributors":[{"name":"test","email":"email","commits":1}]},"readingTime":{"minutes":1.12,"words":336},"filePathRelative":"知识库/JS/浏览器的垃圾回收机制.md","localizedDate":"2024年7月10日","excerpt":"\\n<p>**垃圾回收：**JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不再参与运行时，就需要系统收回被占用的内存空间。​如果不及时清理，会造成系统卡顿、内存溢出，这就是垃圾回收。</p>\\n<ul>\\n<li>JS 具有自动垃圾回收机制。垃圾收集器会按照固定的时间间隔周期性的执行。</li>\\n<li>JS 常见的垃圾回收方式：<strong>标记清除</strong>、<strong>引用计数方式</strong></li>\\n</ul>\\n<h2>哪些情况会导致内存泄漏</h2>\\n<ul>\\n<li>意外的全局变量：由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li>\\n<li>被遗忘的计时器或回调函数：设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li>\\n<li>脱离 DOM 的引用：获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</li>\\n<li>闭包：不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li>\\n</ul>","autoDesc":true}');export{h as comp,d as data};
