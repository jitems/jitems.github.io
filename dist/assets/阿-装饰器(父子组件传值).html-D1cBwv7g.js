import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,b as s,a as t,d as a,o as n}from"./app-Bi9sAhmd.js";const r={},l=t("p",null," ",-1),o=a(`<h1 id="装饰器" tabindex="-1"><a class="header-anchor" href="#装饰器"><span>装饰器</span></a></h1><p>父子页面通过装饰器传值</p><p>ArkUI框架提供了多种管理状态的装饰器来修饰变量，使用这些装饰器修饰的变量即称为状态变量。</p><table><thead><tr><th>场景</th><th>装饰器</th></tr></thead><tbody><tr><td>组件内的状态管理</td><td>@State</td></tr><tr><td>从父组件单向同步状态</td><td>@Prop</td></tr><tr><td>与父组件双向同步状态</td><td>@Link</td></tr><tr><td>跨组件层级双向同步状态</td><td>@Provide和@Consume</td></tr></tbody></table><h2 id="component-装饰器" tabindex="-1"><a class="header-anchor" href="#component-装饰器"><span>@Component 装饰器</span></a></h2><p>@Component 表示这是个自定义组件</p><h2 id="entry-装饰器" tabindex="-1"><a class="header-anchor" href="#entry-装饰器"><span>@Entry 装饰器</span></a></h2><p>@Entry 则表示这是个入口组件</p><h2 id="组件状态管理装饰器" tabindex="-1"><a class="header-anchor" href="#组件状态管理装饰器"><span>组件状态管理装饰器</span></a></h2><p>组件状态管理装饰器用来管理组件中的状态，它们分别是：@State、@Prop、@Link。</p><h3 id="state装饰器-组件内状态" tabindex="-1"><a class="header-anchor" href="#state装饰器-组件内状态"><span>@State装饰器：组件内状态</span></a></h3><p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-state-0000001474017162-V3" target="_blank" rel="noopener noreferrer">@State装饰器</a></p><p>@State装饰的变量是组件内部的状态数据，当这些状态数据被修改时，将会调用所在组件的build方法进行UI刷新。</p><p>@State装饰的变量，与声明式范式中的其他被装饰变量一样，是私有的，只能从组件内部访问，在声明时必须指定其类型和本地初始化。初始化也可选择使用命名参数机制从父组件完成初始化。</p><p>@State装饰的变量拥有以下特点：</p><ul><li>@State装饰的变量与子组件中的@Prop、@Link或@ObjectLink装饰变量之间建立单向或双向数据同步。</li><li>@State装饰的变量生命周期与其所属自定义组件的生命周期相同。</li></ul><h3 id="prop装饰器-父子单向同步" tabindex="-1"><a class="header-anchor" href="#prop装饰器-父子单向同步"><span>@Prop装饰器：父子单向同步</span></a></h3><p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-prop-0000001473537702-V3" target="_blank" rel="noopener noreferrer">@Prop装饰器</a></p><p><strong>概述</strong> @Prop装饰的变量和父组件建立单向的同步关系：</p><ul><li>@Prop变量允许在本地修改，但修改后的变化不会同步回父组件。</li><li>当父组件中的数据源更改时，与之相关的@Prop装饰的变量都会自动更新。如果子组件已经在本地修改了@Prop装饰的相关变量值，而在父组件中对应的@State装饰的变量被修改后，子组件本地修改的@Prop装饰的相关变量值将被覆盖。 <strong>限制条件</strong></li><li>@Prop修饰复杂类型时是深拷贝，在拷贝的过程中除了基本类型、Map、Set、Date、Array外，都会丢失类型。</li><li>@Prop装饰器不能在@Entry装饰的自定义组件中使用。</li></ul><h3 id="link装饰器-父子双向同步" tabindex="-1"><a class="header-anchor" href="#link装饰器-父子双向同步"><span>@Link装饰器：父子双向同步</span></a></h3><p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-link-0000001524297305-V3" target="_blank" rel="noopener noreferrer">@Link装饰器</a></p><p><strong>概述</strong> @Link装饰的变量可以和父组件的@State变量建立双向数据绑定。 需要注意的是：@Link变量不能在组件内部进行初始化。 <strong>限制条件</strong> @Link装饰器不能在@Entry装饰的自定义组件中使用。</p><h3 id="provide装饰器和-consume装饰器-与后代组件双向同步" tabindex="-1"><a class="header-anchor" href="#provide装饰器和-consume装饰器-与后代组件双向同步"><span>@Provide装饰器和@Consume装饰器：与后代组件双向同步</span></a></h3><p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-provide-and-consume-0000001473857338-V3" target="_blank" rel="noopener noreferrer">@Provide装饰器和@Consume装饰器</a></p><p>@Provide和@Consume，应用于与后代组件的双向数据同步，应用于状态数据在多个层级之间传递的场景。不同于上文提到的父子组件之间通过命名参数机制传递，@Provide和@Consume摆脱参数传递机制的束缚，实现跨层级传递。</p><p>其中@Provide装饰的变量是在祖先节点中，可以理解为被“提供”给后代的状态变量。@Consume装饰的变量是在后代组件中，去“消费（绑定）”祖先节点提供的变量。</p><p><strong>概述</strong> @Provide/@Consume装饰的状态变量有以下特性：</p><ul><li>@Provide装饰的状态变量自动对其所有后代组件可用，即该变量被“provide”给他的后代组件。由此可见，@Provide的方便之处在于，开发者不需要多次在组件之间传递变量。</li><li>后代通过使用@Consume去获取@Provide提供的变量，建立在@Provide和@Consume之间的双向数据同步，与@State/@Link不同的是，前者可以在多层级的父子组件之间传递。</li><li>@Provide和@Consume可以通过相同的变量名或者相同的变量别名绑定，变量类型必须相同。</li></ul><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" data-title="ts" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 通过相同的变量名绑定</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">Provide</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">number</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">Consume</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">number</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 通过相同的变量别名绑定</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Provide</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&#39;a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">number</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Consume</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&#39;a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;">c</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">number</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>@Provide和@Consume通过相同的变量名或者相同的变量别名绑定时，@Provide修饰的变量和@Consume修饰的变量是一对多的关系。不允许在同一个自定义组件内，包括其子组件中声明多个同名或者同别名的@Provide装饰的变量</p><h3 id="observed装饰器和-objectlink装饰器-嵌套类对象属性变化" tabindex="-1"><a class="header-anchor" href="#observed装饰器和-objectlink装饰器-嵌套类对象属性变化"><span>@Observed装饰器和@ObjectLink装饰器：嵌套类对象属性变化</span></a></h3><p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-observed-and-objectlink-0000001473697338-V3" target="_blank" rel="noopener noreferrer">@Observed装饰器和@ObjectLink装饰器</a></p><p>上文所述的装饰器仅能观察到第一层的变化，但是在实际应用开发中，应用会根据开发需要，封装自己的数据模型。对于多层嵌套的情况，比如二维数组，或者数组项class，或者class的属性是class，他们的第二层的属性变化是无法观察到的。这就引出了@Observed/@ObjectLink装饰器。</p><p><strong>概述</strong></p><p>@ObjectLink和@Observed类装饰器用于在涉及嵌套对象或数组的场景中进行双向数据同步：</p><ul><li>被@Observed装饰的类，可以被观察到属性的变化；</li><li>子组件中@ObjectLink装饰器装饰的状态变量用于接收@Observed装饰的类的实例，和父组件中对应的状态变量建立双向数据绑定。这个实例可以是数组中的被@Observed装饰的项，或者是class object中的属性，这个属性同样也需要被@Observed装饰。</li><li>单独使用@Observed是没有任何作用的，需要搭配@ObjectLink或者@Prop使用。</li></ul><p><strong>限制条件</strong></p><ul><li>使用@Observed装饰class会改变class原始的原型链，@Observed和其他类装饰器装饰同一个class可能会带来问题。</li><li>@ObjectLink装饰器不能在@Entry装饰的自定义组件中使用。</li></ul><h2 id="builder装饰器" tabindex="-1"><a class="header-anchor" href="#builder装饰器"><span>@Builder装饰器</span></a></h2><ul><li>@Builder装饰的方法用于定义组件的声明式UI描述，在一个自定义组件内快速生成多个布局内容。</li></ul>`,41);function p(h,d){return n(),i("div",null,[l,s(" more "),o])}const m=e(r,[["render",p],["__file","阿-装饰器(父子组件传值).html.vue"]]),g=JSON.parse('{"path":"/HarmonyOS/%E6%96%B9%E8%88%9F%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/%E9%98%BF-%E8%A3%85%E9%A5%B0%E5%99%A8(%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC).html","title":"装饰器","lang":"zh-CN","frontmatter":{"title":"装饰器","order":1,"category":["前端"],"tag":["HarmonyOS"],"head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/HarmonyOS/%E6%96%B9%E8%88%9F%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/%E9%98%BF-%E8%A3%85%E9%A5%B0%E5%99%A8(%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC).html"}],["meta",{"property":"og:site_name","content":"遐想的猫"}],["meta",{"property":"og:title","content":"装饰器"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-10T06:09:47.000Z"}],["meta",{"property":"article:author","content":"Mr.Liu"}],["meta",{"property":"article:tag","content":"HarmonyOS"}],["meta",{"property":"article:modified_time","content":"2024-07-10T06:09:47.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"装饰器\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-07-10T06:09:47.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Liu\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"@Component 装饰器","slug":"component-装饰器","link":"#component-装饰器","children":[]},{"level":2,"title":"@Entry 装饰器","slug":"entry-装饰器","link":"#entry-装饰器","children":[]},{"level":2,"title":"组件状态管理装饰器","slug":"组件状态管理装饰器","link":"#组件状态管理装饰器","children":[{"level":3,"title":"@State装饰器：组件内状态","slug":"state装饰器-组件内状态","link":"#state装饰器-组件内状态","children":[]},{"level":3,"title":"@Prop装饰器：父子单向同步","slug":"prop装饰器-父子单向同步","link":"#prop装饰器-父子单向同步","children":[]},{"level":3,"title":"@Link装饰器：父子双向同步","slug":"link装饰器-父子双向同步","link":"#link装饰器-父子双向同步","children":[]},{"level":3,"title":"@Provide装饰器和@Consume装饰器：与后代组件双向同步","slug":"provide装饰器和-consume装饰器-与后代组件双向同步","link":"#provide装饰器和-consume装饰器-与后代组件双向同步","children":[]},{"level":3,"title":"@Observed装饰器和@ObjectLink装饰器：嵌套类对象属性变化","slug":"observed装饰器和-objectlink装饰器-嵌套类对象属性变化","link":"#observed装饰器和-objectlink装饰器-嵌套类对象属性变化","children":[]}]},{"level":2,"title":"@Builder装饰器","slug":"builder装饰器","link":"#builder装饰器","children":[]}],"git":{"createdTime":1720591787000,"updatedTime":1720591787000,"contributors":[{"name":"test","email":"email","commits":1}]},"readingTime":{"minutes":5.21,"words":1563},"filePathRelative":"HarmonyOS/方舟开发教程/阿-装饰器(父子组件传值).md","localizedDate":"2024年7月10日","excerpt":"<p>&nbsp;</p>\\n"}');export{m as comp,g as data};
